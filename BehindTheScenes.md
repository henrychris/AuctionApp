# Behind The Scenes

## Description

This document will explain some of the decisions I made while building this and **why**.

## Why SignalR?

SignalR is Microsoft's real-time communication library. It's a very mature product, having been in development since 2011. It's fairly easy to setup and understand, and has rich documentation across all its clients. The main reason is its inbuilt support for groups. A group in SignalR is a collection of connections that messages are sent to. If I had decided to use a message broker to build chat, it would have been much more complicated **and** messy.

### Why Strongly-Typed Hub contexts?

In SignalR, you use Hubs to define methods that connected clients can call on the server.

If I define this in my hub,

```cs
public class ChatHub : Hub
{
    public async Task SendMessage(string user, string message)
        => await Clients.All.SendAsync("ReceiveMessage", user, message);
}
```

A client can invoke the method like so:

```js
try {
  await connection.invoke("SendMessage", user, message);
} catch (err) {
  console.error(err);
}
```

However, if you take a look at the "ReceiveMessage" string, that is a method defined on the client. So, SignalR will send whatever data is passed by the client using the "ReceiveMessage" method. Using strings is a reasonable approach, but, they can easily be misspelled leading to missing messages. This can be prevented.

If the Hub inherits from the an interface, like so:

```cs
public class ChatHub : Hub<IChatClient>
{
}
```

```cs
public interface IChatClient
{
    Task ReceiveMessage(string user, string message);
}
```

We can invoke that method in the ChatHub, like this:

```cs
public async Task SendMessage(string user, string message)
        => await Clients.All.ReceiveMessage(user, message);
```

No chance for mistakes!

Now, SignalR allows you to call Hub methods from outside the hub using an `IHubContext`. The side effect, is that this using this approach means you can't access connection info like the user's connectionId. So, if we inject this into a service like this:

```cs
public class ChatService(IHubContext<ChatHub, IChatClient> hubContext)
```

We can call the methods we defined in `IChatClient`, without fear of making mistakes and losing messages:

```cs
    hubContext.Clients.All.ReceiveMessage(user, message);
```

In addition to this, the client can use enums or constants to ensure messages are received correctly.

## Why MassTransit?

Although RabbitMQ provides an SDK to setup a broker in C#, it can be complicated. MassTransit abstracts the setup into publishers and consumer classes, allowing developers to focus on designing the logic. And, it still allows for deep customisation, if required.

## Why Vertical Slice Architecture?

My earlier projects used the repository, and unit of work patterns frequently. While this structure has its benefits, I found that a single feature often needed changes across multiple layers and tons of mocking when writing tests. With VSA, I can place feature logic close together, even if it means some code duplication. New features are contained in a single folder, and are easy to find and alter.

## Why Postgres?

There is no special reason for choosing Postgres. Initially, I used sqlite as a DB as it was easy to setup and didn't need Docker to run. Once I containerised the application, I noticed that sqlite stopped working - because the database file couldn't be located. At that point, I rebuilt the migrations and switched to Postgres .

## Database Design

There are six domain entities to consider in the database.

### User

Represents a user of the application who can be a normal user or an admin. I only need basic data, so it has a few properties (that I added, the others are auto generated by MS identity.)

- Id: guid.
- FirstName: string.
- LastName: string.
- Role: string.

I also use the Email attribute autogenerated by Identity to store email addresses.

### BaseEntity

All other domain models inherit this class.

- Id: guid.
- DateCreated: datetime.
- LastModifiedDate: datetime.

This adds some metadata allowing an admin to track modifications to a piece of data.

### Auction

Represents an auction for an item.

- Name: string. This is the name of the item up for auction.
- StartingPriceInKobo: int. In fintech applications, it is recommended to store monetary data in the lowest unit of currency, to prevent precision errors.
- StartingTime: datetime.
- ClosingTime: datetime.
- HighestBidAmountInKobo: int. This is initialised to the same value as StartingPriceInKobo.
- AuctionStatus: enum
- HighestBidderId: string. This is to be filled with a valid userId. It is **optional**, and NOT a foreign key, as the auction does not have a highest bidder when created.

### Bid

Represents bid made on an item for auction, within a bidding room.

- AmountInKobo: int.
- UserId: guid. The user who made this bid. This is a foreign key linked to the Users table.
- BiddingRoomId: guid. The room this bid was made in. This is a foreign key linked to the Rooms table.

### BiddingRoom

Represents a bidding room. It mainly exists to track bids made on an auction using its id. The id is also used in SignalR to group connections into a "room".

- RoomStatus: enum.
- AuctionId: guid. A foreign key linked to the auctions table.

### Invoice

Represents an invoice issued to the winner of an auction. I chose to store all the data and not use foreign keys, as invoices should be independent of time. If a user account is deleted and the invoice table uses a userId, then what happens to the data?

- ItemName: string. The item won during the auction.
- AmountInKobo: int. The winning bid.
- UserFirstName: string.
- UserLastName: string.
- UserEmail: string.
- BidId: guid. A foreign key linked to the bids table. Bids are stored permanently, so this data is safe.

### Payment

Represents a payment on an invoice.

- Status: enum.
- InvoiceId: guid. A foreign key linked to the Invoices table.

## Error Handling - Why ErrorOr?

In my earlier projects, and in my previous role, errors would be represented by returning `null`. While this is an okay choice, it meant warnings were littered across the application and we frequently dealt with null exception bugs. I started using the Result pattern as it means I can either return a **value**, an **error** or a list of errors.
When using this pattern, I can return structured, useful errors in a consistent pattern. In this application, all errors follow this structure:

```json
{
  "success": "<boolean>",
  "message": "<string>",
  "errors": [
    {
      "code": "<string>",
      "description": "<string>"
    },
    {
      "code": "<string>",
      "description": "<string>"
    }
  ]
}
```

The message describes the first error in the list, and errors contains 1 to N errors.  
Finally, you'll notice there are no warnings for possible null exceptions in the application, which is thoroughly pleasing.

## Sending Emails

There are two files to reference [SendInvoiceMailRequest.cs](./src/AuctionApp.Application/Features/Mail/SendInvoiceMail/SendInvoiceMailRequest.cs) and [MailService.cs](./src/AuctionApp.Infrastructure/Services/MailService.cs).

In the first file, you'll notice the html stored in a string. This is a necessary evil. I could have chosen to store the file in Azure Blob storage and setup a service to fetch it when needed, but I decided it was overkill for a project of this nature.  
After the template is altered to use the invoice data passed in, `MailService` is called to send the email.

Rather than using a service like SendGrid, I chose to use a simple SMTP server connection as this allows me to send the email straight to a user's inbox, instead of a sandbox environment. If the email fails to send, for whatever reason, an exception is thrown.

MassTransit sets up a queue named `send-invoice-mail-request`, and any messages published to it are consumed by `SendInvoiceMailConsumer`. Exceptions thrown in the consumer are recognised as a failure to process the message. When that happens, MassTransit will requeue the message and retry.

Barring exceptional situations, you can be assured that the message will be processed **once**.
